<?xml version="1.0" encoding="UTF-8"?>
<exportedData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="commander.xsd" version="54" buildLabel="build_4.0_50702_OPT_2012.05.16_13:51:27" buildVersion="4.0.2.50702" passkey="2468db457282d61c50085d36a5b66d570f7f6617">
  <exportPath>/jobs/performanceMetrics_7976</exportPath>
  <job>
    <jobName>performanceMetrics_7976</jobName>
    <directoryName>performanceMetrics_7976</directoryName>
    
    <launchedByUser>admin</launchedByUser>
    <priority>normal</priority>
    <procedureName>performanceMetrics</procedureName>
    <jobStep>
      <stepName>job_608333626117932444-root</stepName>
      <alwaysRun>0</alwaysRun>
      <broadcast>0</broadcast>
      <conditionExpanded>0</conditionExpanded>
      <errorHandling>failProcedure</errorHandling>
      <exclusiveMode>none</exclusiveMode>
      <exitCode>0</exitCode>
      
      <finish>2014-02-12T17:39:10.662Z</finish>
      
      <outcome>warning</outcome>
      <parallel>0</parallel>
      <postExitCode>0</postExitCode>
      <procedureName>performanceMetrics</procedureName>
      <releaseMode>none</releaseMode>
      
      <retries>0</retries>
      <runTime>0</runTime>
      <start>2014-02-12T17:38:27.829Z</start>
      <status>completed</status>
      <subprocedure>performanceMetrics</subprocedure>
      <subproject>EC-Admin</subproject>
      <timeLimit></timeLimit>
      
      <actualParameters>
        <property>
          <propertyName>debugMode</propertyName>
          <expandable>0</expandable>
          <value>0</value>
        </property>
        <property>
          <propertyName>numberOfGB</propertyName>
          <expandable>0</expandable>
          <value>1</value>
        </property>
        <property>
          <propertyName>numberOfJobSteps</propertyName>
          <expandable>0</expandable>
          <value>5000</value>
        </property>
        <property>
          <propertyName>numberOfSteps</propertyName>
          <expandable>0</expandable>
          <value>5</value>
        </property>
      </actualParameters>
      <liveProcedure>performanceMetrics</liveProcedure>
      <propertySheet>
        <property>
          <propertyName>DBPerf</propertyName>
          <expandable>1</expandable>
          <value>0.2</value>
        </property>
        <property>
          <propertyName>PM-numberOfAgents</propertyName>
          <expandable>1</expandable>
          <value>6</value>
        </property>
        <property>
          <propertyName>PM-numberOfJobsPerDay</propertyName>
          <expandable>1</expandable>
          <value>30.0</value>
        </property>
        <property>
          <propertyName>PM-numberOfProjects</propertyName>
          <expandable>1</expandable>
          <value>57</value>
        </property>
        <property>
          <propertyName>PM-numberOfResources</propertyName>
          <expandable>1</expandable>
          <value>11</value>
        </property>
        <property>
          <propertyName>debugMode</propertyName>
          <expandable>0</expandable>
          <value>0</value>
        </property>
        <property>
          <propertyName>numberOfGB</propertyName>
          <expandable>0</expandable>
          <value>1</value>
        </property>
        <property>
          <propertyName>numberOfJobSteps</propertyName>
          <expandable>0</expandable>
          <value>5000</value>
        </property>
        <property>
          <propertyName>numberOfSteps</propertyName>
          <expandable>0</expandable>
          <value>5</value>
        </property>
        <property>
          <propertyName>readDiskPerf</propertyName>
          <expandable>1</expandable>
          <value>256</value>
        </property>
        <property>
          <propertyName>writeDiskPerf</propertyName>
          <expandable>1</expandable>
          <value>170.666666666667</value>
        </property>
      </propertySheet>
      <calledProcedure>
        <jobStep>
          <stepName>Server RAM Amount</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Param&#10;#&#10;$DEBUG=0;&#10;&#10;my $RAM=0;     # Amount of RAM in GB&#10;if ($OSNAME =~ /MSWin/) {&#10;  $RAM=`wmic OS get TotalVisibleMemorySize /Value`;&#10;  chomp $RAM;&#10;  $RAM =~ s/TotalVisibleMemorySize=(\d+)/$1/m;&#10;  $RAM = int($RAM);&#10;  printf("RAM amount: %d\n", $RAM) if ($DEBUG);&#10;  $RAM /= 1048576;  &#10;} elsif ($OSNAME eq "linux") {&#10;  $RAM=`cat /proc/meminfo | grep MemTotal | awk '{print \$2}'`;&#10;  chomp $RAM;&#10;  printf("RAM amount: %d\n", $RAM) if ($DEBUG);&#10;   $RAM /= 1048576;&#10;}  else {&#10;  printf ("OS: %s not supported for Commander Server\n", $OSNAME); &#10;  exit(2);&#10;}&#10;&#10;#&#10;# &#10;#&#10;if ($RAM == 0) {&#10;  printf ("Error getting the RAM amount on %s\n", $OSNAME);&#10;  exit(2);&#10;}&#10;&#10;my $str=sprintf("%3.1f GB\n", $RAM);&#10;printf("RAM amount: $str\n");&#10;checkValue("RAM", $RAM, $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:29.262Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Server RAM Amount.1730629.log</logFileName>
          <outcome>warning</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>369</runTime>
          <runnable>2014-02-12T17:38:27.901Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:28.875Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Server RAM Amount</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>3.9 GB&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Free RAM</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Param&#10;#&#10;$DEBUG=0;&#10;&#10;my $freeRAM=0;     # Amount of RAM in GB&#10;if ($OSNAME =~ /MSWin/) {&#10;  $freeRAM=`systeminfo | find "Available Physical Memory"`;&#10;  chomp $freeRAM;&#10;  printf("free RAM amount: %s\n", $freeRAM) if ($DEBUG);&#10;  # Available Physical Memory: 4,948 MB   or 4,948 in Europe&#10;  $freeRAM =~ s/Available Physical Memory:\s+([\d,.]+) MB/$1/m;&#10;  $freeRAM =~ s/,//;&#10;  printf("RAM amount: %d\n", $freeRAM) if ($DEBUG);&#10;} elsif ($OSNAME eq "linux") {&#10;  $freeRAM=`/usr/bin/free -m | grep "cache:" | awk '{print \$3}'`;&#10;  chomp $freeRAM;&#10;  printf("free RAM amount: %d\n", $freeRAM) if ($DEBUG);&#10;  $freeRAM /= 1024&#10;}  else {&#10;  printf ("OS: %s not supported for Commander Server\n", $OSNAME); &#10;  exit(2);&#10;}&#10;&#10;#&#10;# &#10;#&#10;if ($freeRAM == 0) {&#10;  printf ("Error getting the RAM amount on %s\n", $OSNAME);&#10;  exit(2);&#10;}&#10;&#10;my $str=sprintf("%3.1f MB\n", $freeRAM);&#10;printf("RAM amount: $str\n");&#10;InvokeCommander("SuppressLog", "setProperty", "summary", $str);&#10;&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:29.746Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Free RAM.1730630.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>309</runTime>
          <runnable>2014-02-12T17:38:29.262Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:29.407Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Free RAM</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>3.1 MB&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Disk Space Available</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Param&#10;#&#10;$DEBUG=0;&#10;&#10;my $freeDisk=0;     # Amount of available disk on the Data partition&#10;my $diskPartition="/opt/electriccloud/electriccommander";&#10;&#10;if ($OSNAME =~ /MSWin/) {&#10;  my $drive=substr($diskPartition,0,2);&#10;  printf("Drive:'%s'\n", $drive);&#10;  system('fsutil volume diskfree $drive 2&gt;&amp;1') if ($DEBUG);&#10;  $freeDisk=`fsutil volume diskfree $drive 2&gt;&amp;1`; # | find "avail free"&#10;  chomp $freeDisk;&#10;  if ($freeDisk =~ /avail free/) {&#10;    $freeDisk =~ m/avail free bytes\s+:\s*(\d+)/;&#10;    printf("free Disk Space for %s: %s\n", $diskPartition, $freeDisk) if ($DEBUG);&#10;    $freeDisk=humanSize($freeDisk); &#10;  } else {&#10;    printf("Error:\n$freeDisk\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", $freeDisk);&#10;    exit(1);&#10;  }&#10;} elsif ($OSNAME eq "linux") {&#10;  $freeDisk=`/bin/df -h $diskPartition | tail -1 | awk '{print \$4}'`;&#10;  chomp $freeDisk;&#10;  # Make the unit  as the other ones&#10;  $freeDisk =~ s/G/ GB/;&#10;  $freeDisk =~ s/M/ MB/;&#10;  printf("free Disk Space for %s: %s\n", $diskPartition, $freeDisk) if ($DEBUG);&#10;}  else {&#10;  printf ("OS: %s not supported for Commander Server\n", $OSNAME); &#10;  exit(2);&#10;}&#10;&#10;printf("Disk space available: %s\n", $freeDisk);&#10;InvokeCommander("SuppressLog", "setProperty", "summary", $freeDisk);&#10;&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:30.304Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Disk Space Available.1730631.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>316</runTime>
          <runnable>2014-02-12T17:38:29.746Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:30.016Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Disk Space Available</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>16 GB</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Java Heap</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;$DEBUG=1;&#10;&#10;my $wrapperFile="/opt/electriccloud/electriccommander/conf/wrapper.conf";&#10;my $javaInitMem=0;&#10;my $javaMaxMem=0;&#10;&#10;open FILE, "&lt; $wrapperFile" || die "Cannot open the file $wrapperFile\n";&#10;while (&lt;FILE&gt;) {&#10;  next if /^#/;&#10;  # &#10;  # Let's look at init memory value that is not commented&#10;  if (/^wrapper.java.initmemory/) {&#10;    if (/\.percent/) {&#10;      # wrapper.java.initmemory.percent=20&#10;      $_ =~ m/=\s*(\w+)/;   &#10;      $javaInitMem= $1."%";&#10;    } else {&#10;      # wrapper.java.initmemory=2048&#10;      $_ =~ m/=\s*(\w+)/;   &#10;      $javaInitMem= $1."mb";&#10;    }  &#10;  } elsif (/^wrapper.java.maxmemory/) {&#10;    if (/\.percent/) {&#10;      # wrapper.java.maxmemory.percent=40&#10;      $_ =~ m/=\s*(\w+)/;   &#10;      $javaMaxMem= $1."%";&#10;    } else {&#10;      # wrapper.java.maxmemory=4096&#10;      $_ =~ m/=\s*(\w+)/;   &#10;      $javaMaxMem= $1."mb";&#10;    }  &#10;  }&#10;}&#10;close(FILE);&#10;&#10;my $str=sprintf("Init Java memory: %s\nMax Java memory: %s\n", $javaInitMem, $javaMaxMem);&#10;printf($str);&#10;&#10;InvokeCommander("SuppressLog", "setProperty", "summary", $str);&#10;&#10;exit(0);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:30.794Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Java Heap.1730632.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>275</runTime>
          <runnable>2014-02-12T17:38:30.304Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:30.490Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Java Heap</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>Init Java memory: 20%&#10;Max Java memory: 40%&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Number of Cores</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;my $nbCores;     # Number of cores&#10;if ($OSNAME =~ /MSWin/) {&#10;  $nbCores=$ENV{NUMBER_OF_PROCESSORS};&#10;} elsif ($OSNAME eq "linux") {&#10;  $nbCores=`nproc`;&#10;  chomp $nbCores;&#10;}  else {&#10;  printf ("OS: %s not supported for COmmander server\n", $OSNAME); &#10;  exit(2);&#10;}&#10;&#10;my $str=sprintf("%2d cores\n", $nbCores);&#10;printf("Number of cores: $str\n");&#10;checkValue("CORE", $nbCores, $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:31.394Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Number of Cores.1730633.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>369</runTime>
          <runnable>2014-02-12T17:38:30.794Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:31.000Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Number of Cores</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value> 4 cores&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Server CPU Speed</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;my $CPUspeed;     # Amount of RAM in GB&#10;if ($OSNAME =~ /MSWin/) {&#10;  my @result=`wmic cpu get MaxClockSpeed`; # result on 2nd line&#10;  $CPUspeed = int($result[1])/1000;&#10;} elsif ($OSNAME eq "linux") {&#10;  $CPUspeed=`cat /proc/cpuinfo | grep "cpu MHz" | head -1 |awk '{print \$4}'`;&#10;  chomp $CPUspeed;&#10;  #printf("CPU speed: %s\n", $CPUspeed);&#10;   $CPUspeed /= 1000;&#10;}  else {&#10;  printf ("OS: %s not supported for Commander server\n", $OSNAME); &#10;  exit(2);&#10;}&#10;&#10;my $str=sprintf("%2.1f GHz\n", $CPUspeed);&#10;printf("CPU speed: $str\n");&#10;checkValue("CPU", $CPUspeed, $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:31.969Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Server CPU Speed.1730634.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>377</runTime>
          <runnable>2014-02-12T17:38:31.394Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:31.561Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Server CPU Speed</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>2.3 GHz&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>License Usage</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;my $res=$ec-&gt;getLicenseUsage()-&gt;{responses}-&gt;[0]-&gt;{licenseUsage};&#10;print Dumper($res);&#10;my $str="";&#10;&#10;#&#10;# Concurrent Resources&#10;#&#10;if ($res-&gt;{concurrentResources}-&gt;{maxHosts} ne 'unlimited') {&#10;  $str .= sprintf("%d of %d hosts\n", $res-&gt;{concurrentResources}-&gt;{inUseHosts}, $res-&gt;{concurrentResources}-&gt;{maxHosts}); &#10;}&#10;if ($res-&gt;{concurrentResources}-&gt;{maxProxiedHosts} ne 'unlimited') {&#10;  $str .= sprintf("%d of %d proxies\n", $res-&gt;{concurrentResources}-&gt;{inUseProxiedHosts}, $res-&gt;{concurrentResources}-&gt;{maxProxiedHosts}); &#10;}&#10;&#10;print $res-&gt;{concurrentSteps}-&gt;{maxConcurrentSteps};&#10;#&#10;# Concurrent Steps&#10;#&#10;if ($res-&gt;{concurrentSteps}-&gt;{maxConcurrentSteps} ne 'unlimited') {&#10;  $str .= sprintf("%d of %d steps\n", $res-&gt;{concurrentSteps}-&gt;{runningSteps}, $res-&gt;{concurrentSteps}-&gt;{maxConcurrentSteps}); &#10;}&#10;&#10;#&#10;# Concurrent users&#10;#&#10;if ($res-&gt;{concurrentUsers}-&gt;{maxLicenses} != 999999) {&#10;  $str .= sprintf("%d of %d users\n", $res-&gt;{concurrentUsers}-&gt;{inUseLicenses}, $res-&gt;{concurrentUsers}-&gt;{maxLicenses}); &#10;}&#10;$ec-&gt;setProperty("summary", $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:32.421Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>License Usage.1730635.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>265</runTime>
          <runnable>2014-02-12T17:38:31.969Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:32.128Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>License Usage</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>0 of 60 hosts&#10;0 of 60 proxies&#10;0 of 0 users&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Database Type</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;$DEBUG=1;&#10;&#10;my $DBPropFile="/opt/electriccloud/electriccommander/conf/database.properties";&#10;my $DBType;&#10;open FILE, "&lt; $DBPropFile" || die "Cannot open the file $DBPropFile\n";&#10;while (&lt;FILE&gt;) {&#10;  if (/DB_TYPE/) {&#10;    # Extract DB type&#10;    # COMMANDER_DB_TYPE=mysql&#10;    $_ =~ m/=(\w+)/;   &#10;    $DBType = $1;&#10;    last;&#10;  }&#10;}&#10;close(FILE);&#10;&#10;printf("Database: %s\n", $DBType);&#10;if ($DBType eq "builtin") {&#10;  printf("BAD\n");&#10;  InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;} elsif ($DBType eq "mysql") {&#10;  printf("GOOD\n");&#10;} elsif (($DBType eq "sqlserver") || ($DBType eq "oracle")) {&#10;  printf("BEST\n");&#10;} else {&#10;  printf ("Unknown\n");&#10;  InvokeCommander("SuppressLog", "setProperty", "summary", "UNKNOWN");&#10;  exit(1);&#10;}  &#10;InvokeCommander("SuppressLog", "setProperty", "summary", $DBType);&#10;&#10;exit(0);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:32.905Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Database Type.1730636.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>265</runTime>
          <runnable>2014-02-12T17:38:32.421Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:32.601Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Database Type</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>mysql</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>deploymentSize</stepName>
          <alwaysRun>0</alwaysRun>
          <broadcast>0</broadcast>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:36.599Z</finish>
          
          <logFileName>deploymentSize.1730637.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postLogFileName>deploymentSize.1730637-postp.log</postLogFileName>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>0</runTime>
          <runnable>2014-02-12T17:38:32.961Z</runnable>
          <start>2014-02-12T17:38:33.420Z</start>
          <status>completed</status>
          <subprocedure>subPM-deploymentSize</subprocedure>
          <subproject>EC-Admin</subproject>
          <timeLimit></timeLimit>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>deploymentSize</liveProcedureStep>
          <calledProcedure>
            <jobStep>
              <stepName>agents</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;################################################################################&#10;#&#10;# GLobal variables&#10;#&#10;################################################################################&#10;my $SMALL=50;&#10;my $LARGE=1000;&#10;my $nbAgents;&#10;my $size;&#10;my %hAg;&#10;&#10;my ($ok, $json)=InvokeCommander("SuppressLog", 'getResources');&#10;&#10;#&#10;# Loop over resources to extract unique hostnames&#10;#&#10;foreach my $node ($json-&gt;findnodes('//resource')){&#10;	printf("Processing %s\n", $node-&gt;{hostName});&#10;    $hAg{lc($node-&gt;{hostName})}=1;&#10;}&#10;&#10;$nbAgents=scalar(keys(%hAg));&#10;if ($nbAgents &lt; $SMALL) {&#10;	$size="SMALL";&#10;} elsif ($nbAgents &gt; $LARGE) {&#10;	$size="LARGE";&#10;} else {&#10;	$size="MEDIUM";&#10;}&#10;$ec-&gt;setProperty("summary", "$size: $nbAgents agents");&#10;$ec-&gt;setProperty("/myJob/PM-numberOfAgents", $nbAgents);&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $result;&#10;    my $success = 1;&#10;	my $errMsg;&#10;	my $errCode;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $result = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    if (defined ($result-&gt;{responses}-&gt;[0]-&gt;{error})) {&#10;    	$errCode=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{code};&#10;    	$errMsg=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{message};&#10;    }&#10;&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($result) {&#10;        print "Return data from Commander:\n" .&#10;               Dumper($result) . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $result, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;	my $propName=$node-&gt;{'propertyName'};&#10;    my $value=$node-&gt;{'value'};&#10;    if (defined ($value)) {&#10;      $hashRef-&gt;{$propName}=$node-&gt;{'value'};&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:33.772Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>agents.1730645.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postProcessor></postProcessor>
              
              <procedureName>subPM-deploymentSize</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>326</runTime>
              <runnable>2014-02-12T17:38:32.961Z</runnable>
              <shell>ec-perl</shell>
              <start>2014-02-12T17:38:33.420Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>subPM-deploymentSize</liveProcedure>
              <liveProcedureStep>agents</liveProcedureStep>
              <propertySheet>
                <property>
                  <propertyName>summary</propertyName>
                  <expandable>1</expandable>
                  <value>SMALL: 6 agents</value>
                </property>
              </propertySheet>
            </jobStep>
            <jobStep>
              <stepName>managedResources</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;################################################################################&#10;#&#10;# GLobal variables&#10;#&#10;################################################################################&#10;my $SMALL=100;&#10;my $LARGE=1000;&#10;&#10;my ($ok, $json)=InvokeCommander("SuppressLog", 'getResources');&#10;my $nbResources=scalar ($json-&gt;findnodes('//resource'));&#10;&#10;my $size;&#10;if ($nbResources &lt; $SMALL) {&#10;	$size="SMALL";&#10;} elsif ($nbResources &gt; $LARGE) {&#10;	$size="LARGE";&#10;} else {&#10;	$size="MEDIUM";&#10;}&#10;$ec-&gt;setProperty("summary", "$size: $nbResources resources");&#10;$ec-&gt;setProperty("/myJob/PM-numberOfResources", $nbResources);&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $result;&#10;    my $success = 1;&#10;	my $errMsg;&#10;	my $errCode;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $result = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    if (defined ($result-&gt;{responses}-&gt;[0]-&gt;{error})) {&#10;    	$errCode=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{code};&#10;    	$errMsg=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{message};&#10;    }&#10;&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($result) {&#10;        print "Return data from Commander:\n" .&#10;               Dumper($result) . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $result, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;	my $propName=$node-&gt;{'propertyName'};&#10;    my $value=$node-&gt;{'value'};&#10;    if (defined ($value)) {&#10;      $hashRef-&gt;{$propName}=$node-&gt;{'value'};&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:34.365Z</finish>
              <hostName>localhost</hostName>
              
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postProcessor></postProcessor>
              
              <procedureName>subPM-deploymentSize</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>354</runTime>
              <runnable>2014-02-12T17:38:33.772Z</runnable>
              <shell>ec-perl</shell>
              <start>2014-02-12T17:38:33.979Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>subPM-deploymentSize</liveProcedure>
              <liveProcedureStep>managedResources</liveProcedureStep>
              <propertySheet>
                <property>
                  <propertyName>summary</propertyName>
                  <expandable>1</expandable>
                  <value>SMALL: 11 resources</value>
                </property>
              </propertySheet>
            </jobStep>
            <jobStep>
              <stepName>projects</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;################################################################################&#10;#&#10;# GLobal variables&#10;#&#10;################################################################################&#10;my $SMALL=10;&#10;my $LARGE=100;&#10;my $size;&#10;my $nb=0;&#10;&#10;my ($ok, $json)=InvokeCommander("SuppressLog", 'getProjects');&#10;foreach my $node ($json-&gt;findnodes('//project')) {&#10;    # Skip plugins&#10;    next if ($node-&gt;{pluginName});&#10;	my $name=$node-&gt;{projectName};&#10;    printf("Processing %s\n", $name);&#10;	$nb++;&#10;}&#10;&#10;&#10;if ($nb &lt; $SMALL) {&#10;	$size="SMALL";&#10;} elsif ($nb &gt; $LARGE) {&#10;	$size="LARGE";&#10;} else {&#10;	$size="MEDIUM";&#10;}&#10;$ec-&gt;setProperty("summary", "$size: $nb projects");&#10;$ec-&gt;setProperty("/myJob/PM-numberOfProjects", $nb);&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $result;&#10;    my $success = 1;&#10;	my $errMsg;&#10;	my $errCode;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $result = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    if (defined ($result-&gt;{responses}-&gt;[0]-&gt;{error})) {&#10;    	$errCode=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{code};&#10;    	$errMsg=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{message};&#10;    }&#10;&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($result) {&#10;        print "Return data from Commander:\n" .&#10;               Dumper($result) . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $result, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;	my $propName=$node-&gt;{'propertyName'};&#10;    my $value=$node-&gt;{'value'};&#10;    if (defined ($value)) {&#10;      $hashRef-&gt;{$propName}=$node-&gt;{'value'};&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:35.380Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>projects.1730647.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postProcessor></postProcessor>
              
              <procedureName>subPM-deploymentSize</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>761</runTime>
              <runnable>2014-02-12T17:38:34.365Z</runnable>
              <shell>ec-perl</shell>
              <start>2014-02-12T17:38:34.588Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>subPM-deploymentSize</liveProcedure>
              <liveProcedureStep>projects</liveProcedureStep>
              <propertySheet>
                <property>
                  <propertyName>summary</propertyName>
                  <expandable>1</expandable>
                  <value>MEDIUM: 57 projects</value>
                </property>
              </propertySheet>
            </jobStep>
            <jobStep>
              <stepName>jobsPerDay</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;use DateTime;&#10;&#10;################################################################################&#10;#&#10;# GLobal variables&#10;#&#10;################################################################################&#10;my $SMALL=100;&#10;my $LARGE=1000;&#10;my $size;&#10;my $nbDays=7;		# check over the last 7 days only&#10;my $count=0;		# total number of jobs&#10;my $nb=1.0;&#10;my $MAXJOBS=7000;&#10;my $now="2015-03-12" . "T00:00:00.000Z";&#10;my $weekAgo=calculateDate($nbDays);&#10;&#10;printf("Now: $now\n");&#10;printf("1 week: $weekAgo\n");&#10;&#10;# create filterList&#10;my @filterList;&#10;# only finished jobs&#10;push (@filterList, {"propertyName" =&gt; "status",&#10;                    "operator" =&gt; "equals",&#10;                    "operand1" =&gt; "completed"});&#10;# newer than&#10;push (@filterList, {"propertyName" =&gt; "start",&#10;                    "operator" =&gt; "greaterOrEqual",&#10;                    "operand1" =&gt; $weekAgo});&#10;# older than today midnight&#10;push (@filterList, {"propertyName" =&gt; "start",&#10;                    "operator" =&gt; "lessThan",&#10;                    "operand1" =&gt; $now});&#10;&#10;my ($ok, $json)=InvokeCommander("SuppressLog", 'findObjects', 'job',&#10;									{maxIds =&gt; $MAXJOBS, &#10;                                     numObjects =&gt; $MAXJOBS,&#10;                                     filter =&gt; \@filterList}&#10;								);&#10;$count=scalar($json-&gt;findnodes('//job'));&#10;$nb=$count/$nbDays;&#10;&#10;printf("Count: %d\n", $count);&#10;printf("Average: %3.1f\n", $nb);&#10;if ($nb &lt; $SMALL) {&#10;	$size="SMALL";&#10;} elsif ($nb &gt; $LARGE) {&#10;	$size="LARGE";&#10;} else {&#10;	$size="MEDIUM";&#10;}&#10;$ec-&gt;setProperty("summary", sprintf("$size: %.1f jobs per day", $nb));&#10;$ec-&gt;setProperty("/myJob/PM-numberOfJobsPerDay", sprintf("%.1f", $nb));&#10;&#10;exit(0);&#10;&#10;&#10;#############################################################################&#10;#&#10;#  Return the day/time at midnight X days back&#10;#&#10;#############################################################################&#10;sub calculateDate {&#10;    my $nbDays=shift;&#10;    my $string=DateTime-&gt;now()-&gt;subtract(days =&gt; $nbDays)-&gt;iso8601();&#10;    $string =~ s/(\d{4}-\d{1,2}-\d{1,2})T.*/$1/;&#10;    $string .= "T00:00:00.000Z";&#10;    return $string;&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $result;&#10;    my $success = 1;&#10;	my $errMsg;&#10;	my $errCode;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $result = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    if (defined ($result-&gt;{responses}-&gt;[0]-&gt;{error})) {&#10;    	$errCode=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{code};&#10;    	$errMsg=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{message};&#10;    }&#10;&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($result) {&#10;        print "Return data from Commander:\n" .&#10;               Dumper($result) . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $result, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;	my $propName=$node-&gt;{'propertyName'};&#10;    my $value=$node-&gt;{'value'};&#10;    if (defined ($value)) {&#10;      $hashRef-&gt;{$propName}=$node-&gt;{'value'};&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:36.599Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>jobsPerDay.1730648.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postProcessor></postProcessor>
              
              <procedureName>subPM-deploymentSize</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>1012</runTime>
              <runnable>2014-02-12T17:38:35.380Z</runnable>
              <shell>ec-perl</shell>
              <start>2014-02-12T17:38:35.569Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>subPM-deploymentSize</liveProcedure>
              <liveProcedureStep>jobsPerDay</liveProcedureStep>
              <propertySheet>
                <property>
                  <propertyName>summary</propertyName>
                  <expandable>1</expandable>
                  <value>SMALL: 30.0 jobs per day</value>
                </property>
              </propertySheet>
            </jobStep>
          </calledProcedure>
        </jobStep>
        <jobStep>
          <stepName>Write Disk Performance</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>use IO::Handle;&#10;#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;my $nbGBs=1;&#10;my $filename = "output.txt";&#10;&#10;open my $numbers_outfile, "&gt;", $filename&#10;    or die "could not open $filename: $!";&#10;&#10;$numbers_outfile-&gt;autoflush(1);&#10;&#10;my $startTime = time();&#10;#each time through the loop should be 1 gig&#10;for (1 .. $nbGBs) {&#10;    #each time though the loop should be 1 meg&#10;    for (1 .. 1024) {&#10;        #print 1 meg of Zs&#10;        print {$numbers_outfile} "Z" x (1024*1024)&#10;    }&#10;}&#10;my $totalTime=time()-$startTime;&#10;close $numbers_outfile;&#10;&#10;# Let's keep the file around for the read performance&#10;#unlink ($filename);&#10;&#10;printf("To write %d GB, it took %d sec\n", $nbGBs, $totalTime);&#10;&#10;my$WRITEspeed=$nbGBs * 1024 / $totalTime;&#10;$ec-&gt;setProperty("/myJob/writeDiskPerf", $WRITEspeed);&#10;my $str=sprintf("%5.1f MB/s\n", $WRITEspeed);&#10;printf("Disk Write speed: $str\n");&#10;checkValue("DISKWRITE", $WRITEspeed, $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:42.908Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Write Disk Performan.1730638.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>6071</runTime>
          <runnable>2014-02-12T17:38:36.599Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:36.807Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Write Disk Performance</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>170.7 MB/s&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>Read Disk Performance </stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>use IO::Handle;&#10;#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;my $nbGBs=1;&#10;&#10;# the file was created by the previous step&#10;my $filename = "output.txt";&#10;&#10;open FILE, "&lt; $filename"&#10;    or die "could not open $filename: $!";&#10;binmode FILE;&#10;&#10;my $startTime = time();&#10;my ($data, $n);&#10;# Let's read the file by 1K&#10;while (($n = read(FILE, $data, 1024)) != 0) {}&#10;close FILE;&#10;&#10;my $totalTime=time()-$startTime;&#10;close FILE;&#10;unlink ($filename);&#10;&#10;printf("To read %d GB, it took %d sec\n", $nbGBs, $totalTime); &#10;my $READspeed=$nbGBs * 1024 / $totalTime;&#10;$ec-&gt;setProperty("/myJob/readDiskPerf", $READspeed);&#10;my $str=sprintf("%5.1f MB/s\n", $READspeed);&#10;printf("Disk Read speed: $str\n");&#10;checkValue("DISKREAD", $READspeed, $str);&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:47.691Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Read Disk Performanc.1730639.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>4558</runTime>
          <runnable>2014-02-12T17:38:42.908Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:43.101Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Read Disk Performance </liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>256.0 MB/s&#10;</value>
            </property>
          </propertySheet>
        </jobStep>
        <jobStep>
          <stepName>localUsage</stepName>
          <alwaysRun>0</alwaysRun>
          <broadcast>0</broadcast>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:49.801Z</finish>
          
          <logFileName>localUsage.1730640.log</logFileName>
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postLogFileName>localUsage.1730640-postp.log</postLogFileName>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>0</runTime>
          <runnable>2014-02-12T17:38:47.747Z</runnable>
          <start>2014-02-12T17:38:48.060Z</start>
          <status>completed</status>
          <subprocedure>subPM-localUsage</subprocedure>
          <subproject>EC-Admin</subproject>
          <timeLimit></timeLimit>
          
          <actualParameters>
            <property>
              <propertyName>debugMode</propertyName>
              <expandable>0</expandable>
              <value>0</value>
            </property>
            <property>
              <propertyName>number</propertyName>
              <expandable>0</expandable>
              <value>5000</value>
            </property>
          </actualParameters>
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>localUsage</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>debugMode</propertyName>
              <expandable>0</expandable>
              <value>0</value>
            </property>
            <property>
              <propertyName>number</propertyName>
              <expandable>0</expandable>
              <value>5000</value>
            </property>
          </propertySheet>
          <calledProcedure>
            <jobStep>
              <stepName>localUsage</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>#############################################################################&#10;#&#10;#  findSteps -- Script to find steps and figure out where they run&#10;#  Copyright 2014 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;&#10;#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;use Data::Dumper;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander({'format' =&gt; "json"});&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;&#10;#### Line 20 ####&#10;&#10;#############################################################################&#10;#&#10;#  Assign Commander parameters to variables&#10;#&#10;#############################################################################&#10;my $totalJobs= 5000;&#10;$DEBUG=0;&#10;&#10;#############################################################################&#10;#&#10;#  Global Variables&#10;#&#10;#############################################################################&#10;my $totalTime=0;&#10;my $localTime=0;&#10;my $totalSteps=0;&#10;my $localSteps=0;&#10;&#10;my $serverName=lc("ecmaster");&#10;my $serverIP="192.168.56.50";&#10;&#10;# create filterList&#10;my @filterList;&#10;# only finished jobSteps&#10;push (@filterList, {"propertyName" =&gt; "status",&#10;                    "operator" =&gt; "equals",&#10;                    "operand1" =&gt; "completed"});&#10;&#10;#&#10;# get newest first&#10;my ($ok, $res)= InvokeCommander("SuppressLog", "findObjects", "jobStep",&#10;                                 {numObjects =&gt; $totalJobs,&#10;                                  filter =&gt; \@filterList,&#10;                                  sort =&gt; [ {propertyName =&gt; "finish",&#10;                                                    order =&gt; "descending"} ]&#10;                                 }&#10;                                );&#10;foreach my $step ($res-&gt;findnodes('//jobStep')) {&#10;    	my $rtime=$step-&gt;{runTime};&#10;        my $host=lc($step-&gt;{hostName});&#10;        next if ($host eq "");&#10;        $totalSteps++;&#10;        $totalTime+=$rtime;&#10;        if (($host eq "localhost") || ($host eq $serverName) || ($host eq $serverIP)){&#10;          #printf("  Step %s (%d)\n", $step-&gt;{stepName}, $rtime)  if ($DEBUG);&#10;          $localTime += $rtime;&#10;          $localSteps ++;&#10;        } else {&#10;          printf("NOT LOCAL: $host  -&gt; %s\n", $step-&gt;{stepName}) if ($DEBUG);&#10;        }&#10;}&#10;&#10;printf("Job time spent on local: %d ms\n", $localTime);&#10;printf("Total job time: %d ms\n", $totalTime);&#10;my $percTime=$localTime*100/$totalTime;&#10;printf("%.1f%% of job time spent on local\n\n", $percTime);&#10;&#10;printf("Number of steps on local: %d\n", $localSteps);&#10;printf("Total number of steps: %d\n", $totalSteps);&#10;my $percSteps=$localSteps*100/$totalSteps;&#10;printf("%.1f%% of steps spent on local\n", $percSteps);&#10;&#10;$ec-&gt;setProperty("summary", sprintf("%03.1f%% time\n%03.1f%% steps", $percTime, $percSteps));&#10;#&#10;# Perl Commander library&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $result;&#10;    my $success = 1;&#10;	my $errMsg;&#10;	my $errCode;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $result = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    if (defined ($result-&gt;{responses}-&gt;[0]-&gt;{error})) {&#10;    	$errCode=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{code};&#10;    	$errMsg=$result-&gt;{responses}-&gt;[0]-&gt;{error}-&gt;{message};&#10;    }&#10;&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($result) {&#10;        print "Return data from Commander:\n" .&#10;               Dumper($result) . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $result, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;	my $propName=$node-&gt;{'propertyName'};&#10;    my $value=$node-&gt;{'value'};&#10;    if (defined ($value)) {&#10;      $hashRef-&gt;{$propName}=$node-&gt;{'value'};&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:49.801Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>localUsage.1730649.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postProcessor></postProcessor>
              
              <procedureName>subPM-localUsage</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>1737</runTime>
              <runnable>2014-02-12T17:38:47.747Z</runnable>
              <shell>ec-perl</shell>
              <start>2014-02-12T17:38:48.060Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>subPM-localUsage</liveProcedure>
              <liveProcedureStep>localUsage</liveProcedureStep>
              <propertySheet>
                <property>
                  <propertyName>summary</propertyName>
                  <expandable>1</expandable>
                  <value>100.0% time&#10;99.9% steps</value>
                </property>
              </propertySheet>
            </jobStep>
          </calledProcedure>
        </jobStep>
        <jobStep>
          <stepName>Performance</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;my %hostsHash; # List of agents already tested&#10;#Let's loop on Resources&#10;my ($success, $xPath) = InvokeCommander("SuppressLog", "getResources");&#10;my $nodeset = $xPath-&gt;find('//resource');&#10;&#10;foreach my $node ($nodeset-&gt;get_nodelist) {&#10;  my $resName=$node-&gt;findvalue('resourceName');&#10;  my $resDisabled=$node-&gt;findvalue('resourceDisabled');&#10;  my $agentAlive=$node-&gt;findvalue('agentState/alive');&#10;  my $hostName=$node-&gt;findvalue('hostName');&#10;  printf("%s\n\t Disabled: %s\n\t alive: %s\n", $resName, $resDisabled, $agentAlive) if ($DEBUG);&#10;  #&#10;  # Create a sub-step only if agent is alive and not disabled&#10;  # to avoid to have to wait (and fail) for unavailable resources&#10;  if (!exists($hostsHash{$hostName})) {&#10;    if ( ($resDisabled eq "0") &amp;&amp; ($agentAlive eq "1") ) {&#10;      my $hostName=$node-&gt;findvalue('hostName');&#10;	  $ec-&gt;createJobStep({'jobStepName' =&gt; $resName,&#10;                        'subprocedure' =&gt; "subPM-performance",&#10;                        'parallel' =&gt; 1,&#10;                        'actualParameter'=&gt;[{actualParameterName =&gt; 'hostname', value =&gt; $hostName},&#10;                        					{actualParameterName =&gt; 'resource', value =&gt; $$resName}]&#10;                        }); &#10;      $hostsHash{$hostName}=1;  # Mark host as tested&#10;    } &#10;  }&#10;}&#10;&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:38:58.230Z</finish>
          <hostName>localhost</hostName>
          
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>659</runTime>
          <runnable>2014-02-12T17:38:49.801Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:50.036Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Performance</liveProcedureStep>
          <calledProcedure>
            <jobStep>
              <stepName>ecadmin-lin</stepName>
              <alwaysRun>0</alwaysRun>
              <broadcast>0</broadcast>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:58.230Z</finish>
              
              <logFileName>ecadmin-lin.1730650.log</logFileName>
              <outcome>success</outcome>
              <parallel>1</parallel>
              <postExitCode>0</postExitCode>
              <postLogFileName>ecadmin-lin.1730650-postp.log</postLogFileName>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>0</runTime>
              <runnable>2014-02-12T17:38:50.424Z</runnable>
              <start>2014-02-12T17:38:50.985Z</start>
              <status>completed</status>
              <subprocedure>subPM-performance</subprocedure>
              <subproject>EC-Admin</subproject>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <actualParameters>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>192.168.56.50</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>ecadmin-lin</value>
                </property>
              </actualParameters>
              <liveProcedure>performanceMetrics</liveProcedure>
              <propertySheet>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>192.168.56.50</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>ecadmin-lin</value>
                </property>
              </propertySheet>
              <calledProcedure>
                <jobStep>
                  <stepName>performance</stepName>
                  <alwaysRun>0</alwaysRun>
                  <assignedResourceName>ecadmin-lin</assignedResourceName>
                  <broadcast>0</broadcast>
                  <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;#&#10;my $hostname="192.168.56.50";&#10;my $resource="ecadmin-lin";&#10;&#10;&#10;my $start = time();&#10;for (my $i=0; $i &lt; 4469134; $i++) {dec2bin(3);}&#10;my $totalTime = time()-$start;&#10;&#10;my $str=sprintf("%s: %d s\n", $hostname, $totalTime);&#10;checkValue("PERF", $totalTime, $str);&#10;exit(0);&#10;&#10;&#10;# 2004&#10;# Xah&#10;# xah@xahlee.org&#10;# http://xahlee.org/&#10;&#10;# convert to/from binary&#10;sub dec2bin {&#10;  my $str = unpack ("B32", pack("N", shift ));&#10;  $str =~ s@^0+(?=\d)@@; # otherwise you'll get leading zeros&#10;  return $str;&#10;}&#10;&#10;&#10;</command>
                  <condition>1</condition>
                  <conditionExpanded>1</conditionExpanded>
                  <errorHandling>failProcedure</errorHandling>
                  <exclusiveMode>none</exclusiveMode>
                  <exitCode>0</exitCode>
                  
                  <finish>2014-02-12T17:38:58.230Z</finish>
                  <hostName>192.168.56.50</hostName>
                  
                  <logFileName>performance.1730651.log</logFileName>
                  <outcome>success</outcome>
                  <parallel>0</parallel>
                  <postExitCode>0</postExitCode>
                  <postProcessor></postProcessor>
                  
                  <procedureName>subPM-performance</procedureName>
                  <releaseMode>none</releaseMode>
                  <resourceName>ecadmin-lin</resourceName>
                  <resourceSource>procedureStep</resourceSource>
                  
                  <retries>0</retries>
                  <runTime>7231</runTime>
                  <runnable>2014-02-12T17:38:50.424Z</runnable>
                  <shell>ec-perl</shell>
                  <start>2014-02-12T17:38:50.985Z</start>
                  <status>completed</status>
                  <timeLimit>600</timeLimit>
                  <timeout>2014-02-12T17:48:50.781Z</timeout>
                  <workingDirectory></workingDirectory>
                  <workspaceName>ecadmin-lin-wks</workspaceName>
                  
                  <liveProcedure>subPM-performance</liveProcedure>
                  <liveProcedureStep>performance</liveProcedureStep>
                  <propertySheet>
                    <property>
                      <propertyName>summary</propertyName>
                      <expandable>1</expandable>
                      <value>192.168.56.50: 6 s&#10;</value>
                    </property>
                  </propertySheet>
                </jobStep>
              </calledProcedure>
            </jobStep>
            <jobStep>
              <stepName>local</stepName>
              <alwaysRun>0</alwaysRun>
              <broadcast>0</broadcast>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:58.124Z</finish>
              
              <logFileName>local.1730652.log</logFileName>
              <outcome>success</outcome>
              <parallel>1</parallel>
              <postExitCode>0</postExitCode>
              <postLogFileName>local.1730652-postp.log</postLogFileName>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>0</runTime>
              <runnable>2014-02-12T17:38:50.650Z</runnable>
              <start>2014-02-12T17:38:51.026Z</start>
              <status>completed</status>
              <subprocedure>subPM-performance</subprocedure>
              <subproject>EC-Admin</subproject>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <actualParameters>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>localhost</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>local</value>
                </property>
              </actualParameters>
              <liveProcedure>performanceMetrics</liveProcedure>
              <propertySheet>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>localhost</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>local</value>
                </property>
              </propertySheet>
              <calledProcedure>
                <jobStep>
                  <stepName>performance</stepName>
                  <alwaysRun>0</alwaysRun>
                  <assignedResourceName>local</assignedResourceName>
                  <broadcast>0</broadcast>
                  <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;#&#10;my $hostname="localhost";&#10;my $resource="local";&#10;&#10;&#10;my $start = time();&#10;for (my $i=0; $i &lt; 4469134; $i++) {dec2bin(3);}&#10;my $totalTime = time()-$start;&#10;&#10;my $str=sprintf("%s: %d s\n", $hostname, $totalTime);&#10;checkValue("PERF", $totalTime, $str);&#10;exit(0);&#10;&#10;&#10;# 2004&#10;# Xah&#10;# xah@xahlee.org&#10;# http://xahlee.org/&#10;&#10;# convert to/from binary&#10;sub dec2bin {&#10;  my $str = unpack ("B32", pack("N", shift ));&#10;  $str =~ s@^0+(?=\d)@@; # otherwise you'll get leading zeros&#10;  return $str;&#10;}&#10;&#10;&#10;</command>
                  <condition>1</condition>
                  <conditionExpanded>1</conditionExpanded>
                  <errorHandling>failProcedure</errorHandling>
                  <exclusiveMode>none</exclusiveMode>
                  <exitCode>0</exitCode>
                  
                  <finish>2014-02-12T17:38:58.124Z</finish>
                  <hostName>localhost</hostName>
                  
                  <logFileName>performance.1730653.log</logFileName>
                  <outcome>success</outcome>
                  <parallel>0</parallel>
                  <postExitCode>0</postExitCode>
                  <postProcessor></postProcessor>
                  
                  <procedureName>subPM-performance</procedureName>
                  <releaseMode>none</releaseMode>
                  <resourceName>local</resourceName>
                  <resourceSource>procedureStep</resourceSource>
                  
                  <retries>0</retries>
                  <runTime>7063</runTime>
                  <runnable>2014-02-12T17:38:50.650Z</runnable>
                  <shell>ec-perl</shell>
                  <start>2014-02-12T17:38:51.026Z</start>
                  <status>completed</status>
                  <timeLimit>600</timeLimit>
                  <timeout>2014-02-12T17:48:50.885Z</timeout>
                  <workingDirectory></workingDirectory>
                  <workspaceName>default</workspaceName>
                  
                  <liveProcedure>subPM-performance</liveProcedure>
                  <liveProcedureStep>performance</liveProcedureStep>
                  <propertySheet>
                    <property>
                      <propertyName>summary</propertyName>
                      <expandable>1</expandable>
                      <value>localhost: 6 s&#10;</value>
                    </property>
                  </propertySheet>
                </jobStep>
              </calledProcedure>
            </jobStep>
          </calledProcedure>
        </jobStep>
        <jobStep>
          <stepName>Database Performance</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;#&#10;my $nbSteps=5;&#10;&#10;my $startTime = time();&#10;for (my $i=1; $i &lt;= $nbSteps; $i++) {&#10;  $ec-&gt;createJobStep({'jobStepName' =&gt; "DBperf-$i",&#10;                      'command'     =&gt; "echo Test $i Done"&#10;                        }); &#10;}&#10;my $totalTime=time()-$startTime;&#10;&#10;printf("To run %d steps, it took %d sec\n", $nbSteps, $totalTime);&#10;my $DBperf=$totalTime/$nbSteps;&#10;my $str=sprintf("%.3f step/sec\n", $DBperf);&#10;$ec-&gt;setProperty('/myJob/DBPerf', $DBperf);&#10;&#10;printf("Database performance: $str\n");&#10;checkValue("DBPERF", $DBperf, $str);&#10;&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:39:00.230Z</finish>
          <hostName>localhost</hostName>
          
          <logFileName>Database Performance.1730642.log</logFileName>
          <outcome>warning</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>975</runTime>
          <runnable>2014-02-12T17:38:58.230Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:38:58.477Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Database Performance</liveProcedureStep>
          <propertySheet>
            <property>
              <propertyName>summary</propertyName>
              <expandable>1</expandable>
              <value>0.200 step/sec&#10;</value>
            </property>
          </propertySheet>
          <calledProcedure>
            <jobStep>
              <stepName>DBperf-1</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>echo Test 1 Done</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:59.448Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>DBperf-1.1730654.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>7</runTime>
              <runnable>2014-02-12T17:38:58.714Z</runnable>
              <start>2014-02-12T17:38:59.063Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>performanceMetrics</liveProcedure>
            </jobStep>
            <jobStep>
              <stepName>DBperf-2</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>echo Test 2 Done</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:59.626Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>DBperf-2.1730656.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>4</runTime>
              <runnable>2014-02-12T17:38:59.448Z</runnable>
              <start>2014-02-12T17:38:59.580Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>performanceMetrics</liveProcedure>
            </jobStep>
            <jobStep>
              <stepName>DBperf-3</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>echo Test 3 Done</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:38:59.815Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>DBperf-3.1730657.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>5</runTime>
              <runnable>2014-02-12T17:38:59.626Z</runnable>
              <start>2014-02-12T17:38:59.772Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>performanceMetrics</liveProcedure>
            </jobStep>
            <jobStep>
              <stepName>DBperf-4</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>echo Test 4 Done</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:39:00.020Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>DBperf-4.1730658.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>5</runTime>
              <runnable>2014-02-12T17:38:59.815Z</runnable>
              <start>2014-02-12T17:38:59.975Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>performanceMetrics</liveProcedure>
            </jobStep>
            <jobStep>
              <stepName>DBperf-5</stepName>
              <alwaysRun>0</alwaysRun>
              <assignedResourceName>local</assignedResourceName>
              <broadcast>0</broadcast>
              <command>echo Test 5 Done</command>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:39:00.230Z</finish>
              <hostName>localhost</hostName>
              
              <logFileName>DBperf-5.1730659.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>6</runTime>
              <runnable>2014-02-12T17:39:00.020Z</runnable>
              <start>2014-02-12T17:39:00.184Z</start>
              <status>completed</status>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <liveProcedure>performanceMetrics</liveProcedure>
            </jobStep>
          </calledProcedure>
        </jobStep>
        <jobStep>
          <stepName>PingTime</stepName>
          <alwaysRun>0</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;my %hostsHash; # List of agents already tested&#10;#Let's loop on Resources&#10;my ($success, $xPath) = InvokeCommander("SuppressLog", "getResources");&#10;my $nodeset = $xPath-&gt;find('//resource');&#10;&#10;foreach my $node ($nodeset-&gt;get_nodelist) {&#10;  my $resName=$node-&gt;findvalue('resourceName');&#10;  my $resDisabled=$node-&gt;findvalue('resourceDisabled');&#10;  my $agentAlive=$node-&gt;findvalue('agentState/alive');&#10;  my $hostName=$node-&gt;findvalue('hostName');&#10;  printf("%s\n\t Disabled: %s\n\t alive: %s\n", $resName, $resDisabled, $agentAlive) if ($DEBUG);&#10;  #&#10;  # Create a sub-step only if agent is alive and not disabled&#10;  # to avoid to have to wait (and fail) for unavailable resources&#10;  if ( ($resDisabled eq "0") &amp;&amp; ($agentAlive eq "1") &amp;&amp; !exists($hostsHash{$hostName})) {&#10;    my $hostName=$node-&gt;findvalue('hostName');&#10;	$ec-&gt;createJobStep({'jobStepName' =&gt; $resName,&#10;                        'subprocedure' =&gt; "subPM-ping",&#10;                        'actualParameter'=&gt;[{actualParameterName =&gt; 'hostname', value =&gt; $hostName},&#10;                        					{actualParameterName =&gt; 'resource', value =&gt; $resName}]&#10;                        }); &#10;    $hostsHash{$hostName}=1;  # Mark host as tested&#10;  }&#10;}&#10;&#10;&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:39:10.335Z</finish>
          <hostName>localhost</hostName>
          
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          
          <retries>0</retries>
          <runTime>599</runTime>
          <runnable>2014-02-12T17:39:00.230Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:39:00.464Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>PingTime</liveProcedureStep>
          <calledProcedure>
            <jobStep>
              <stepName>ecadmin-lin</stepName>
              <alwaysRun>0</alwaysRun>
              <broadcast>0</broadcast>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:39:05.568Z</finish>
              
              <logFileName>ecadmin-lin.1730660.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postLogFileName>ecadmin-lin.1730660-postp.log</postLogFileName>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>0</runTime>
              <runnable>2014-02-12T17:39:00.813Z</runnable>
              <start>2014-02-12T17:39:01.133Z</start>
              <status>completed</status>
              <subprocedure>subPM-ping</subprocedure>
              <subproject>EC-Admin</subproject>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <actualParameters>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>192.168.56.50</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>ecadmin-lin</value>
                </property>
              </actualParameters>
              <liveProcedure>performanceMetrics</liveProcedure>
              <propertySheet>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>192.168.56.50</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>ecadmin-lin</value>
                </property>
              </propertySheet>
              <calledProcedure>
                <jobStep>
                  <stepName>ping</stepName>
                  <alwaysRun>0</alwaysRun>
                  <assignedResourceName>local</assignedResourceName>
                  <broadcast>0</broadcast>
                  <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;#&#10;my $hostname="192.168.56.50";&#10;my $resource="ecadmin-lin";&#10;&#10;#&#10;# Global Variables&#10;# &#10;my $pingCount=5;&#10;my $avgPing=0;&#10;my $result;&#10;my $str;&#10;&#10;if ($OSNAME eq "linux") {&#10;  $result=`ping -c $pingCount -q $hostname | tail -1`;&#10;&#10;  if ($result =~ /rtt/) {&#10;    # rtt min/avg/max/mdev = 0.167/0.190/0.238/0.027 ms&#10;    $result =~ m#[\d\.]+/([\d\.]+)/[\d\.]+/[\d\.]+#;&#10;    $avgPing=$1;&#10;  } elsif ($result =~ /unknown host/) {&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unknown");&#10;    exit(2);&#10;  } else {&#10;    # unreachable host&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unreachable");&#10;    exit(1);&#10;  }&#10;  $str=sprintf("%s: %4.3f ms\n", $hostname, $avgPing);&#10;} else {   # Windows&#10;  $result=`C:/Windows/system32/ping -n $pingCount $hostname`;&#10;  &#10;  if ($result =~ /Minimum/) {&#10;    #  Minimum = 178ms, Maximum = 530ms, Average = 357ms&#10;    $result =~ m/Average = (\d+)ms/;&#10;    $avgPing=$1;&#10;  } elsif ($result =~ /could not find host/) {&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unknown");&#10;    exit(2);&#10;  } else {&#10;    # unreachable host&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unreachable");&#10;    exit(1);&#10;  }&#10;  $str=sprintf("%s: %d ms\n", $hostname, $avgPing);&#10;}&#10;&#10;checkValue("PING", $avgPing, $str);&#10;&#10;</command>
                  <condition>1</condition>
                  <conditionExpanded>1</conditionExpanded>
                  <errorHandling>failProcedure</errorHandling>
                  <exclusiveMode>none</exclusiveMode>
                  <exitCode>0</exitCode>
                  
                  <finish>2014-02-12T17:39:05.568Z</finish>
                  <hostName>localhost</hostName>
                  
                  <logFileName>ping.1730661.log</logFileName>
                  <outcome>success</outcome>
                  <parallel>0</parallel>
                  <postExitCode>0</postExitCode>
                  <postProcessor></postProcessor>
                  
                  <procedureName>subPM-ping</procedureName>
                  <releaseMode>none</releaseMode>
                  
                  <retries>0</retries>
                  <runTime>4406</runTime>
                  <runnable>2014-02-12T17:39:00.813Z</runnable>
                  <shell>ec-perl</shell>
                  <start>2014-02-12T17:39:01.133Z</start>
                  <status>completed</status>
                  <timeLimit></timeLimit>
                  <workingDirectory></workingDirectory>
                  <workspaceName>default</workspaceName>
                  
                  <liveProcedure>subPM-ping</liveProcedure>
                  <liveProcedureStep>ping</liveProcedureStep>
                  <propertySheet>
                    <property>
                      <propertyName>summary</propertyName>
                      <expandable>1</expandable>
                      <value>192.168.56.50: 0.047 ms&#10;</value>
                    </property>
                  </propertySheet>
                </jobStep>
              </calledProcedure>
            </jobStep>
            <jobStep>
              <stepName>local</stepName>
              <alwaysRun>0</alwaysRun>
              <broadcast>0</broadcast>
              <condition>1</condition>
              <conditionExpanded>1</conditionExpanded>
              <errorHandling>failProcedure</errorHandling>
              <exclusiveMode>none</exclusiveMode>
              <exitCode>0</exitCode>
              
              <finish>2014-02-12T17:39:10.335Z</finish>
              
              <logFileName>local.1730662.log</logFileName>
              <outcome>success</outcome>
              <parallel>0</parallel>
              <postExitCode>0</postExitCode>
              <postLogFileName>local.1730662-postp.log</postLogFileName>
              <procedureName>performanceMetrics</procedureName>
              <releaseMode>none</releaseMode>
              
              <retries>0</retries>
              <runTime>0</runTime>
              <runnable>2014-02-12T17:39:05.655Z</runnable>
              <start>2014-02-12T17:39:05.927Z</start>
              <status>completed</status>
              <subprocedure>subPM-ping</subprocedure>
              <subproject>EC-Admin</subproject>
              <timeLimit></timeLimit>
              <workingDirectory></workingDirectory>
              <workspaceName>default</workspaceName>
              
              <actualParameters>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>localhost</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>local</value>
                </property>
              </actualParameters>
              <liveProcedure>performanceMetrics</liveProcedure>
              <propertySheet>
                <property>
                  <propertyName>hostname</propertyName>
                  <expandable>0</expandable>
                  <value>localhost</value>
                </property>
                <property>
                  <propertyName>resource</propertyName>
                  <expandable>0</expandable>
                  <value>local</value>
                </property>
              </propertySheet>
              <calledProcedure>
                <jobStep>
                  <stepName>ping</stepName>
                  <alwaysRun>0</alwaysRun>
                  <assignedResourceName>local</assignedResourceName>
                  <broadcast>0</broadcast>
                  <command>#############################################################################&#10;#&#10;# Copyright 2013 Electric-Cloud Inc.&#10;#&#10;#############################################################################&#10;use strict;&#10;use English;&#10;use ElectricCommander;&#10;$| = 1;&#10;&#10;my $DEBUG=0;&#10;&#10;# Create a single instance of the Perl access to ElectricCommander&#10;my $ec = new ElectricCommander();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#############################################################################&#10;#&#10;# Compare 2 version number strings like x.y.z... section by section&#10;# return 1 if V1 &gt; v2&#10;# return 0 if v1 == v2&#10;# return -1 if v1 &lt; v2&#10;#&#10;#############################################################################&#10;sub compareVersion {&#10;&#10;  my ($v1, $v2)=@_;&#10;  &#10;  my @v1Numbers = split('\.', $v1);&#10;  my @v2Numbers = split('\.', $v2);&#10;&#10;  for (my $index = 0; $index &lt; scalar(@v1Numbers); $index++) {&#10;    &#10;    # We ran out of V2 numbers =&gt; V1 is a bigger version&#10;    return 1 if (scalar(@v2Numbers) == $index);&#10;&#10;    # same value, go to next number&#10;    next if ($v1Numbers[$index] == $v2Numbers[$index]);&#10;        &#10;    # V1 is a bigger version&#10;    return 1 if ($v1Numbers[$index] &gt; $v2Numbers[$index]);&#10;           ;&#10;    # V2 is a bigger version&#10;    return -1;&#10;  }&#10;&#10;  # We ran out of V1 numbers&#10;  return -1 if(scalar(@v1Numbers) != scalar(@v2Numbers));&#10;&#10;  # Same number&#10;  return 0;&#10;};&#10;&#10;#############################################################################&#10;#&#10;# Return property value or undef in case of error (non existing)&#10;#&#10;#############################################################################&#10;sub getP&#10;{&#10;  my $prop=shift;&#10;&#10;  my($success, $xPath, $errMsg, $errCode)= InvokeCommander("SuppressLog IgnoreError", "getProperty", $prop);&#10;  return undef if ($success != 1);&#10;  my $val= $xPath-&gt;findvalue("//value");&#10;  return($val);&#10;}&#10;&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Return human readable size&#10;#&#10;#############################################################################&#10;sub humanSize {&#10;  my $size = shift();&#10;&#10;  if ($size &gt; 1099511627776) { # TB: 1024 GB&#10;      return sprintf("%.2f TB", $size / 1099511627776);&#10;  }&#10;  if ($size &gt; 1073741824) { # GB: 1024 MB&#10;      return sprintf("%.2f GB", $size / 1073741824);&#10;  }&#10;  if ($size &gt; 1048576) { # MB: 1024 KB&#10;      return sprintf("%.2f MB", $size / 1048576);&#10;  }&#10;  elsif ($size &gt; 1024) { # KiB: 1024 B&#10;      return sprintf("%.2f KB", $size / 1024);&#10;  }&#10;                                  # bytes&#10;  return "$size byte" . ($size &lt;= 1 ? "" : "s");&#10;};&#10;;&#10;&#10;#############################################################################&#10;#&#10;# Invoke a API call&#10;#&#10;#############################################################################&#10;sub InvokeCommander {&#10;&#10;    my $optionFlags = shift;&#10;    my $commanderFunction = shift;&#10;    my $xPath;&#10;    my $success = 1;&#10;&#10;    my $bSuppressLog = $optionFlags =~ /SuppressLog/i;&#10;    my $bSuppressResult = $bSuppressLog || $optionFlags =~ /SuppressResult/i;&#10;    my $bIgnoreError = $optionFlags =~ /IgnoreError/i;&#10;&#10;    # Run the command&#10;    # print "Request to Commander: $commanderFunction\n" unless ($bSuppressLog);&#10;&#10;    $ec-&gt;abortOnError(0) if $bIgnoreError;&#10;    $xPath = $ec-&gt;$commanderFunction(@_);&#10;    $ec-&gt;abortOnError(1) if $bIgnoreError;&#10;&#10;    # Check for error return&#10;    my $errMsg = $ec-&gt;checkAllErrors($xPath);&#10;    my $errCode=$xPath-&gt;findvalue('//code',)-&gt;value();&#10;    if ($errMsg ne "") {&#10;        $success = 0;&#10;    }&#10;    if ($xPath) {&#10;        print "Return data from Commander:\n" .&#10;               $xPath-&gt;findnodes_as_string("/") . "\n"&#10;            unless $bSuppressResult;&#10;    }&#10;&#10;    # Return the result&#10;    return ($success, $xPath, $errMsg, $errCode);&#10;}&#10;&#10;&#10;#############################################################################&#10;#&#10;# Return a hash of the properties contained in a Property Sheet.&#10;# Args:&#10;#    1. Property Sheet path&#10;#    2. Recursive boolean&#10;#############################################################################&#10;sub getPS&#10;{&#10;  my $psPath=shift;&#10;  my $recursive=shift;&#10;  &#10;  my $hashRef=undef;&#10;  &#10;  my($success, $result, $errMsg, $errCode)=InvokeCommander("SuppressLog IgnoreError", "getProperties", {'path'=&gt;$psPath});&#10;  return $hashRef if (!$success);&#10;  &#10; &#10;  foreach my $node ($result-&gt;findnodes('//property')) {&#10;    my $propName=$node-&gt;findvalue('propertyName');&#10;    my $value   =$node-&gt;findvalue('value')-&gt;string_value();&#10;    my $psId    =$node-&gt;findvalue('propertySheetId');&#10;    &#10;    # this is not a nested PS    &#10;    if ($psId eq '') {&#10;      $hashRef-&gt;{$propName}=$value;&#10;      printf("%s: %s\n", $propName, $value);&#10;    } else {&#10;      # nested PropertySheet&#10;      if ($recursive) {&#10;        $hashRef-&gt;{$propName}=getPS("$psPath/$propName", $recursive);&#10;      } else {&#10;        $hashRef-&gt;{$propName}=undef;&#10;      }  &#10;    }&#10;  }&#10;  return $hashRef;&#10;}&#10;&#10;sub checkValue&#10;{&#10;  my $test=shift;            # the test to perform&#10;  my $value=shift;         # the value to test&#10;  my $summary=shift;   # the summary to display on the job page&#10;&#10;  printf("Value to test: %s\n", $value) if ($DEBUG);&#10;  printf("Checking Performance for %s: ", $test);&#10; &#10;  InvokeCommander("SuppressLog", "setProperty", "summary", $summary);&#10;  if (eval $value .  getP("/myProject/performances/$test/BAD")) {&#10;    printf("BAD\n");&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    return -1;&#10;  } elsif (eval $value . getP("/myProject/performances/$test/GOOD")) {&#10;    printf("GOOD\n");&#10;    return 0;&#10;  } elsif(eval $value . getP("/myProject/performances/$test/BEST")) {&#10;    printf("BEST\n");&#10;    return +1;&#10;  } else {&#10;    printf ("\nTest for %s does not resolve. Verify your values in the performances property sheet\n", $test);&#10;    exit (2);&#10;  }&#10;}&#10;&#10;#&#10;# Parameters&#10;#&#10;my $hostname="localhost";&#10;my $resource="local";&#10;&#10;#&#10;# Global Variables&#10;# &#10;my $pingCount=5;&#10;my $avgPing=0;&#10;my $result;&#10;my $str;&#10;&#10;if ($OSNAME eq "linux") {&#10;  $result=`ping -c $pingCount -q $hostname | tail -1`;&#10;&#10;  if ($result =~ /rtt/) {&#10;    # rtt min/avg/max/mdev = 0.167/0.190/0.238/0.027 ms&#10;    $result =~ m#[\d\.]+/([\d\.]+)/[\d\.]+/[\d\.]+#;&#10;    $avgPing=$1;&#10;  } elsif ($result =~ /unknown host/) {&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unknown");&#10;    exit(2);&#10;  } else {&#10;    # unreachable host&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unreachable");&#10;    exit(1);&#10;  }&#10;  $str=sprintf("%s: %4.3f ms\n", $hostname, $avgPing);&#10;} else {   # Windows&#10;  $result=`C:/Windows/system32/ping -n $pingCount $hostname`;&#10;  &#10;  if ($result =~ /Minimum/) {&#10;    #  Minimum = 178ms, Maximum = 530ms, Average = 357ms&#10;    $result =~ m/Average = (\d+)ms/;&#10;    $avgPing=$1;&#10;  } elsif ($result =~ /could not find host/) {&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unknown");&#10;    exit(2);&#10;  } else {&#10;    # unreachable host&#10;    InvokeCommander("SuppressLog", "setProperty", "outcome", "warning");&#10;    InvokeCommander("SuppressLog", "setProperty", "summary", "$hostname unreachable");&#10;    exit(1);&#10;  }&#10;  $str=sprintf("%s: %d ms\n", $hostname, $avgPing);&#10;}&#10;&#10;checkValue("PING", $avgPing, $str);&#10;&#10;</command>
                  <condition>1</condition>
                  <conditionExpanded>1</conditionExpanded>
                  <errorHandling>failProcedure</errorHandling>
                  <exclusiveMode>none</exclusiveMode>
                  <exitCode>0</exitCode>
                  
                  <finish>2014-02-12T17:39:10.335Z</finish>
                  <hostName>localhost</hostName>
                  
                  <logFileName>ping.1730663.log</logFileName>
                  <outcome>success</outcome>
                  <parallel>0</parallel>
                  <postExitCode>0</postExitCode>
                  <postProcessor></postProcessor>
                  
                  <procedureName>subPM-ping</procedureName>
                  <releaseMode>none</releaseMode>
                  
                  <retries>0</retries>
                  <runTime>4370</runTime>
                  <runnable>2014-02-12T17:39:05.655Z</runnable>
                  <shell>ec-perl</shell>
                  <start>2014-02-12T17:39:05.927Z</start>
                  <status>completed</status>
                  <timeLimit></timeLimit>
                  <workingDirectory></workingDirectory>
                  <workspaceName>default</workspaceName>
                  
                  <liveProcedure>subPM-ping</liveProcedure>
                  <liveProcedureStep>ping</liveProcedureStep>
                  <propertySheet>
                    <property>
                      <propertyName>summary</propertyName>
                      <expandable>1</expandable>
                      <value>localhost: 0.084 ms&#10;</value>
                    </property>
                  </propertySheet>
                </jobStep>
              </calledProcedure>
            </jobStep>
          </calledProcedure>
        </jobStep>
        <jobStep>
          <stepName>Clean Disk Performance Temporary File</stepName>
          <alwaysRun>1</alwaysRun>
          <assignedResourceName>local</assignedResourceName>
          <broadcast>0</broadcast>
          <command>my $filename = "output.txt";&#10;&#10;if (-f $filename) {&#10;  unlink($filename);&#10;  printf("Deleting %s\n", $filename);&#10;}&#10;</command>
          <condition>1</condition>
          <conditionExpanded>1</conditionExpanded>
          <errorHandling>failProcedure</errorHandling>
          <exclusiveMode>none</exclusiveMode>
          <exitCode>0</exitCode>
          
          <finish>2014-02-12T17:39:10.662Z</finish>
          <hostName>localhost</hostName>
          
          <outcome>success</outcome>
          <parallel>0</parallel>
          <postExitCode>0</postExitCode>
          <postProcessor></postProcessor>
          
          <procedureName>performanceMetrics</procedureName>
          <releaseMode>none</releaseMode>
          <resourceName>local</resourceName>
          <resourceSource>procedureStep</resourceSource>
          
          <retries>0</retries>
          <runTime>14</runTime>
          <runnable>2014-02-12T17:39:10.335Z</runnable>
          <shell>ec-perl</shell>
          <start>2014-02-12T17:39:10.593Z</start>
          <status>completed</status>
          <timeLimit></timeLimit>
          <workingDirectory></workingDirectory>
          <workspaceName>default</workspaceName>
          
          <liveProcedure>performanceMetrics</liveProcedure>
          <liveProcedureStep>Clean Disk Performance Temporary File</liveProcedureStep>
        </jobStep>
      </calledProcedure>
    </jobStep>
    <liveProcedure>performanceMetrics</liveProcedure>
    <projectName>EC-Admin</projectName>
    <workspaceName>default</workspaceName>
    <workspaceName>ecadmin-lin-wks</workspaceName>
  </job>
</exportedData>
